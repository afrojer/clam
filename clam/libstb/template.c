/*
 * Template C file for CLAM backend
 * Jeremy C. Andrus <jeremya@cs.columbia.edu>
 * 2011-12-12
 */

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include "clam.h"

#define bail(msg, ...) \
{ \
	fprintf(stderr, "CLAM Runtime ERROR: " msg "\n", ## __VA_ARGS__ ); \
	exit(EXIT_FAILURE); \
}

/* _really_ basic argument handling */
static char *INFILE = NULL;
static char *OUTFILE = NULL;
static char OUTFMT[4] = { 0, 0, 0, 0 };

/* --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- */
/*                                                                 */
/* CLAM heavy lifting functions                                    */
/*                                                                 */
/* --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- */

void __clam_imgchan_add(clam_img *img, clam_calcFunc f,
			clam_atom type, const char *name, int should_alloc)
{
	clam_imgchan *chan;

	chan = malloc(sizeof(*chan));
	if (!chan)
		bail("no memory for channel");

	INIT_LIST_HEAD(&chan->list);
	chan->name = name;
	chan->f = f;
	chan->stride = clam_atom_sz(type);
	if (should_alloc) {
		chan->p = malloc(img->width * img->height * chan->stride);
		if (!chan->p)
			bail("no memory for channel");
	} else
		chan->p = NULL;

	list_add_tail(&chan->list, &img->chan);
	img->num_chan++;
}

void clam_imgchan_add(clam_img *img, clam_calcFunc f,
		  clam_atom type, const char *name)
{
	__clam_imgchan_add(img, f, type, name, 1);
}


clam_imgchan *clam_imgchan_ref(clam_img *img, const char *name)
{
	clam_imgchan *ch;
	list_for_each_entry(ch, &img->chan, list) {
		if (strcmp(name, ch->name) == 0) {
			goto out;
		}
	}
	bail("Invalid channel: %s", name);
out:
	return ch;
}

void clam_imgchan_assign(clam_img *dimg, const char *dname,
		     clam_img *simg, const char *sname)
{
	clam_imgchan *dst, *src;
	int sz;

	if (dimg->width != simg->width ||
	    dimg->height != simg->height)
	{
		/* we could fix this by dynamically resizing... */
		bail("incompatible images\n");
	}

	dst = clam_imgchan_ref(dimg, dname);
	src = clam_imgchan_ref(simg, sname);
	sz = dimg->width * dimg->height;

	if (dst->stride == src->stride) {
		memcpy(dst->p, src->p, sz * dst->stride);
	} else {
		int pix;
		for (pix = 0; pix < sz; ++pix) {
			/* XXX - we have to cast here!! */
			/*       this means we need a set of annoying
			 *       functions to cast up/down between our
			 *       different channel types...
			 */
		}
	}
}

void clam_imgchan_eval(clam_img *img, const char *name)
{
	clam_imgchan *ch;
	int found_it;
	int pix;
	int sz = img->width * img->height;
	clam_calcFunc f = ch->f;
	unsigned char *chan_ptr = malloc(sz * ch->stride);

	ch = clam_imgchan_ref(img, name);

	/* already calculated */
	if (ch->p)
		return;

	sz = img->width * img->height;
	f = ch->f;
	chan_ptr = malloc(sz * ch->stride);
	if (!chan_ptr)
		bail("No memory for channel %s", name);
	ch->p = chan_ptr;

	clam_img_setup_calc(img);
	for ( pix = 0; pix < sz; ++pix) {
		f(img->curr_p, img->num_chan, chan_ptr);
		chan_ptr += ch->stride;
		clam_img_next_pix(img);
	}
}

/* --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- */
/*                                                                 */
/* Everything below this line should be generated                  */
/*                                                                 */
/* --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- */

/* Variable declarations */
char *imgread_arg1;
clam_img *srcimg;
clam_calc *Lum;
clam_calc *sobelG;
clam_calc *sobelTheta;
clam_img *edges;
clam_img *output;

/* CalcT functions */
static inline void calcFunc_Lum(unsigned char **pp,
				size_t num_chan, void *val)
{
	/* autogenerated list of pixel data pointers */
	/* Red = 0 */
	/* Green = 1 */
	/* Blue = 2 */
	uint8_t *pix = (uint8_t *)val;
	uint8_t Red = clam_img_pix(uint8_t,pp,0);
	uint8_t Green = clam_img_pix(uint8_t,pp,1);
	uint8_t Blue = clam_img_pix(uint8_t,pp,2);
	/* #[ ... ]# */
	*pix = (3*Red + 6*Green + 1*Blue)/10;
}

/* main program loop */
int main(int argc, char **argv)
{
	/* _really_ basic argument handling */
	if (argc > 1) {
		size_t sz = strlen(argv[1]) + 1;
		INFILE = malloc(sz);
		if (!INFILE) bail("no space for arguments");
		strncpy(INFILE, argv[1], sz);
	}
	if (argc > 2) {
		size_t sz = strlen(argv[2]) + 1;
		char *fmt;
		OUTFILE = malloc(sz);
		if (!OUTFILE) bail("no space for arguments");
		strncpy(OUTFILE, argv[2], sz);
		/* find the format */
		fmt = strrchr(OUTFILE, '.');
		if (fmt && (OUTFILE + sz - ++fmt) > 3)
			strncpy(OUTFMT, fmt, 4);
	}

	/* Image srcimage = imgread(...) */
	imgread_arg1 = INFILE;
	srcimg = imgread(imgread_arg1);
	if (!srcimg) bail(""); /* error printed from imgread() */

	/* Calc Lum := ... */
	Lum = clam_calc_alloc();
	if (!Lum) bail("out of memory!");

	/* XXX - missing stuff! */

	/* srcimg |= Lum */
	__clam_imgchan_add(srcimg, calcFunc_Lum, UINT8, "Lum", 0);

	/* $(srcimg:Lum) */
	clam_imgchan_eval(srcimg, "Lum");

	/* testing... */
	output = clam_img_alloc();
	output->width = srcimg->width;
	output->height = srcimg->height;
	clam_imgchan_add(output, NULL, UINT8, "Red");
	clam_imgchan_add(output, NULL, UINT8, "Green");
	clam_imgchan_add(output, NULL, UINT8, "Blue");

	/* output:Red = srcimg:Lum */
	clam_imgchan_assign(output, "Red", srcimg, "Lum");
	/* output:Green = srcimg:Lum */
	clam_imgchan_assign(output, "Green", srcimg, "Lum");
	/* output:Blue = srcimg:Lum */
	clam_imgchan_assign(output, "Blue", srcimg, "Lum");
	
	if (OUTFILE) {
		printf("Copying to: (%s) %s\n", OUTFMT, OUTFILE);
		imgwrite(output, OUTFMT, OUTFILE);
	}

	return EXIT_SUCCESS;
}

