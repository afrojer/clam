\chapter{Test Plan}
\label{chap:testplan}

Our unit test framework consists of pairs of identically named files in the \texttt{clam/tests/} directory.
Each pair consists of a CLAM program with extension \texttt{.clam} and an executable shell script
with extension \texttt{.test}. The CLAM file contains the code to be tested, while the shell script
specifies how to test that code: whether to compile and run or only compile, whether the test is supposed to fail,
what the expected output should look like, and what command line arguments to pass.
The \texttt{_buildup.sh} sets up the testing environment and defines common procedures such as
\texttt{compile_it} and \texttt{run_it}. Furthermore, \texttt{all.test} runs all tests in the directory,
tallies successes and failures and outputs a summary at the end.\\

Our testing is divided into four sections: syntax verification, semantic/type verification, CString verification, and functional output verification (image processing results comparison). 

\section{Syntax Verification}
\label{testing:syntax}

Syntax verification is meant to confirm that the parser accepts all token strings,
and rejects all invalid ones as defined in our language reference manual.
We achieve this by inspecting \texttt{clam/parser.mly} and writing unit tests for
potentially problematic cases (many of the more straightforward rules were not deemed test-worthy).
The testing process uncovered a number of errors
in matrix parsing and definition of kernel calculation lists.\\

\texttt{matrix1.clam} tests that a simple matrix parses correctly, and should pass:
\lstinputlisting[language=CLAM]{../clam/tests/matrix1.clam}
(This originally failed because a scale factor was required, but now it is accepted.)

\texttt{matrix2.clam} tests that a matrix with scaling factor parses correctly, and should pass:
\lstinputlisting[language=CLAM]{../clam/tests/matrix2.clam}

\texttt{matrix3.clam} tests whether the parser catches ill-formed matrices, and should fail:
\lstinputlisting[language=CLAM]{../clam/tests/matrix3.clam}
(This originally succeeded due to incorrect matrix parsing rules, but now it fails.)

\texttt{matrix4.clam} tests whether the parser catches another type of ill-formed matrix, and should also fail:
\lstinputlisting[language=CLAM]{../clam/tests/matrix4.clam}
(This originally succeeded due to incorrect matrix parsing rules, but now it fails.)

\texttt{keyword-id.clam} tests whether the parser allows keywords to be identifiers, and should fail:
\lstinputlisting[language=CLAM]{../clam/tests/keyword-id.clam}


\section{Semantic Verification}
\label{testing:semantic}

Semantic verification is meant to confirm that the verifier accepts all valid parse trees,
and rejects all invalid ones as defined our language reference manual.
We achieve this by going through the various rules in \texttt{clam/verifier.ml}
and one of more unit tests for each. The testing process uncovered a number of errors
in matrix parsing and definition of kernel calculation lists.\\

\texttt{image-eq-image.clam} checks \texttt{=} assignment for images to images. This should compile:
\lstinputlisting[language=CLAM]{../clam/tests/image-eq-image.clam}

\texttt{image-eq-image.clam} checks \texttt{|=} assignment for images to images. This is not supported and fails:
\lstinputlisting[language=CLAM]{../clam/tests/image-eq-image.clam}

\texttt{image-defeq.clam} checks \texttt{:=} assignment for images. This is not supported and fails:
\lstinputlisting[language=CLAM]{../clam/tests/image-defeq.clam}

\section{CString Verification}
\label{testing:cstrings}

\section{Image Processing Verification}
\label{test:output}


We start from part 1, using small unit tests to find out bugs in the syntax of CLAM. We carefully went through those data types and operators defined in CLAM to ensure the convergence. In detail, the default value of each basic type, the validity operands of all kinds of operators, and different ways of declaration are main points in this part. We also plan to fix those syntax bugs, especially in the parser and the verifier, immediately after them were found. Thus, at the end of the part 1, our  parser become more robust and capable of handling syntax errors.

In part two, we test the acceptance of wrapped C expression. The code in CLAM is translated into C language before being compiled, and C language expressions are supported during variable declaration. As a reason of that,  the parser needs to detect syntax errors in those wrapped C statements that may affect the compiling. Some tests about unreasonable statements are also involved such as 0 being denominator, or unclosed comment.

The functionalities of built-in functions and calculation operators in CLAM are tested in part 3. The actual images are required in the tests as input and output. The output of each test is observed and compared with desired result.

CLAM Syntax:
	Assignments: 
		addker2img.clam, addker.clam, DefEq.clam

	** operator:
		convoperand.clam

	Variable deceleration:
		1calc_ker.clam, zerocalc1.clam, zerocalc2.clam
		defcalc1.clam, defcalc2.clam, defcalc3.clam
id_overlap.clam, invalid_identifier.clam
		undefined_atomtype.clam
		

	Image operations syntax (not testing actual implementation):
		imgchannel1.clam, imgchannel2.clam, imgchannel3.clam, imgchannel4.clam
		imgread_bad.clam, imgwrite_bad1.clam, imgread_bad2.clam, imgread_bad3.clam
		defchannels.clam, sizediff.clam, equality_trans.clam

	The @ operator: at_channel.clam
	Comment: comment1.clam

	rval_calc.clam, rval_matrix.clam, rval_chanref.clam, rval_conv.clam, 
	rval_cstr.clam, rval_image.clam, rval_imgread.clam, rval_kernel.clam


Warped C syntax:
	cstring1.clam, cstring2.clam, cstring3.clam, cstring4.clam, cstring5.clam, cstring6.clam
	cimage.clam
	ckernel.clam

Image functionality:
	imgwrite_norgb.clam,  imgcopy.clam,  imgread.clam
	sobel.clam (general test)
