\chapter{Architectural Design}

% Give block diagram showing the major components of your translator
% Describe the interfaces between the components
% State who implemented each component

% TODO: Diagram of the layers of CLAM

Our design incorporates six layers: the scanner, the parser, the verifier,
the semantic converter, the backend C generation, and C image manipulation
libraries. The compiler takes as input a text file containing a valid \sys{}
program and outputs a binary that implements the program described by the
input text.

The scanner generates as its output a one-dimensional list of tokens. Each
token must be from the following list:

% TODO: List of Tokens

The parser reads this token list and uses our context-free grammar to generate
an abstract syntax tree. The parser is not strict about which nodes have
which children, or whether or not it is meaningful to have the current
structure: rather it just blindly assembles the tree. The abstract syntax tree
has the following possible nodes:

% TODO: List of AST Nodes

The verifier accepts as input an abstract syntax tree. It traverses the
tree and checks that nodes are arranged in meaningful ways. While it
traverses, it also builds up an environment that keeps track of all
variables defined, along with their identifier name and type. If the
verifier accepts the AST, it will return as output the cumulative
environment that contains the identifiers and their types.

The semantic converter takes in a verified abstract syntax tree and also the
list of variables generated by the verifier. It then maps each node or
configuration of nodes to a corresponding Semantic AST node that
corresponds more directly with the eventual C code that must be generated.
The output of this layer is a semantically checked abstract syntax tree
(SAST). The semantic converter also supplements the environment information
inherited from the verifier with additional information not related to
verification, such the largest referenced command-line argument.

% TODO: Mapping of AST -> SAST

The backend takes as input the SAST and the supplemented environment
information. It then converts this into a meaningful C++ program source
file. This program can be submitted to GCC and compiled.

The final layer of \sys{} is the GCC compiler. The generated C source from
the backend is fed into the GCC compiler, which outputs a binary in
architecture-specific assembly language.

The lead developers for each layer of \sys{} are:

% TODO: Table of lead <-> layer
